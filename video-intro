#!/usr/bin/env python3
"""
video-intro: Add a title screen image to the beginning of a video.
"""

import argparse
import json
import subprocess
import sys
import tempfile
import os
from pathlib import Path


def get_video_info(video_path: str) -> dict:
    """Get video properties using ffprobe."""
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "v:0",
        "-show_entries", "stream=width,height,r_frame_rate,pix_fmt,codec_name,profile",
        "-of", "json",
        video_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    data = json.loads(result.stdout)
    stream = data["streams"][0]

    return {
        "width": int(stream["width"]),
        "height": int(stream["height"]),
        "fps_str": stream["r_frame_rate"],
        "pix_fmt": stream.get("pix_fmt", "yuv420p"),
        "codec": stream.get("codec_name", "h264"),
        "profile": stream.get("profile", "High"),
    }


def get_audio_info(video_path: str) -> dict | None:
    """Get audio properties using ffprobe."""
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "a:0",
        "-show_entries", "stream=codec_name,sample_rate,channels,bit_rate,channel_layout",
        "-of", "json",
        video_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    data = json.loads(result.stdout)

    if not data.get("streams"):
        return None

    stream = data["streams"][0]

    # Determine channel layout
    channels = int(stream.get("channels", 2))
    channel_layout = stream.get("channel_layout", "stereo" if channels >= 2 else "mono")

    # Get bitrate, default to 128k if not available
    bitrate = stream.get("bit_rate")
    if bitrate:
        bitrate = int(bitrate)
    else:
        bitrate = 128000

    return {
        "codec": stream.get("codec_name", "aac"),
        "sample_rate": int(stream.get("sample_rate", 44100)),
        "channels": channels,
        "channel_layout": channel_layout,
        "bitrate": bitrate,
    }


def get_stream_order(video_path: str) -> list[str]:
    """Get the order of streams (video/audio) in the original file."""
    cmd = [
        "ffprobe",
        "-v", "error",
        "-show_entries", "stream=codec_type",
        "-of", "json",
        video_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    data = json.loads(result.stdout)
    return [s["codec_type"] for s in data.get("streams", [])]


def create_intro_video(
    image_path: str,
    duration: float,
    video_info: dict,
    audio_info: dict | None,
    stream_order: list[str],
    output_path: str
) -> None:
    """Create intro video from image matching the main video's specs exactly."""
    w, h = video_info["width"], video_info["height"]
    fps = video_info["fps_str"]
    pix_fmt = video_info["pix_fmt"]

    # Check if audio comes first in original
    audio_first = audio_info and stream_order and stream_order[0] == "audio"

    # Build FFmpeg command for intro
    args = ["ffmpeg", "-y"]

    if audio_first and audio_info:
        # Audio input first to match original stream order
        args.extend([
            "-f", "lavfi",
            "-i", f"anullsrc=channel_layout={audio_info['channel_layout']}:sample_rate={audio_info['sample_rate']}",
            "-loop", "1",
            "-i", image_path,
        ])
    else:
        args.extend([
            "-loop", "1",
            "-i", image_path,
        ])
        if audio_info:
            args.extend([
                "-f", "lavfi",
                "-i", f"anullsrc=channel_layout={audio_info['channel_layout']}:sample_rate={audio_info['sample_rate']}",
            ])

    # Video filter to match dimensions and format
    vf = (
        f"scale={w}:{h}:force_original_aspect_ratio=decrease,"
        f"pad={w}:{h}:(ow-iw)/2:(oh-ih)/2,setsar=1,format={pix_fmt}"
    )

    args.extend(["-t", str(duration)])

    # Map streams in correct order
    if audio_first and audio_info:
        args.extend([
            "-map", "0:a",
            "-map", "1:v",
            "-vf", vf,
            "-r", fps,
            "-c:v", "libx264",
            "-profile:v", "high",
            "-preset", "fast",
            "-crf", "18",
            "-pix_fmt", pix_fmt,
            "-c:a", "aac",
            "-b:a", f"{audio_info['bitrate']}",
            "-ar", str(audio_info['sample_rate']),
            "-ac", str(audio_info['channels']),
            "-shortest",
        ])
    else:
        args.extend([
            "-vf", vf,
            "-r", fps,
            "-c:v", "libx264",
            "-profile:v", "high",
            "-preset", "fast",
            "-crf", "18",
            "-pix_fmt", pix_fmt,
        ])
        if audio_info:
            args.extend([
                "-c:a", "aac",
                "-b:a", f"{audio_info['bitrate']}",
                "-ar", str(audio_info['sample_rate']),
                "-ac", str(audio_info['channels']),
                "-shortest",
            ])

    args.append(output_path)

    result = subprocess.run(args, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Error creating intro: {result.stderr}", file=sys.stderr)
        sys.exit(1)


def concatenate_videos(intro_path: str, main_path: str, output_path: str) -> None:
    """Concatenate videos using concat demuxer with stream copy (no re-encoding)."""
    with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
        f.write(f"file '{intro_path}'\n")
        f.write(f"file '{main_path}'\n")
        concat_file = f.name

    try:
        args = [
            "ffmpeg", "-y",
            "-f", "concat",
            "-safe", "0",
            "-i", concat_file,
            "-c", "copy",
            output_path
        ]

        result = subprocess.run(args, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Error concatenating: {result.stderr}", file=sys.stderr)
            sys.exit(1)
    finally:
        os.unlink(concat_file)


def main():
    parser = argparse.ArgumentParser(
        description="Add a title screen image to the beginning of a video.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  video-intro --image title.png --video screencast.mp4 --output final.mp4
  video-intro -i logo.png -v demo.mp4 -d 3 -o output.mp4
        """
    )

    parser.add_argument(
        "-i", "--image",
        required=True,
        help="Path to the title screen image (PNG, JPG, etc.)"
    )
    parser.add_argument(
        "-v", "--video",
        required=True,
        help="Path to the input video (MP4)"
    )
    parser.add_argument(
        "-d", "--duration",
        type=float,
        required=True,
        help="Duration of the title screen in seconds"
    )
    parser.add_argument(
        "-o", "--output",
        required=True,
        help="Path for the output video"
    )

    args = parser.parse_args()

    # Validate inputs
    image_path = os.path.abspath(os.path.expanduser(args.image))
    video_path = os.path.abspath(os.path.expanduser(args.video))

    if not Path(image_path).exists():
        print(f"Error: Image file not found: {image_path}", file=sys.stderr)
        sys.exit(1)

    if not Path(video_path).exists():
        print(f"Error: Video file not found: {video_path}", file=sys.stderr)
        sys.exit(1)

    if args.duration <= 0:
        print("Error: Duration must be positive", file=sys.stderr)
        sys.exit(1)

    # Check for FFmpeg
    try:
        subprocess.run(["ffmpeg", "-version"], capture_output=True, check=True)
    except FileNotFoundError:
        print("Error: FFmpeg not found. Please install FFmpeg.", file=sys.stderr)
        sys.exit(1)

    # Get video/audio properties
    print(f"Analyzing: {video_path}")
    video_info = get_video_info(video_path)
    audio_info = get_audio_info(video_path)
    stream_order = get_stream_order(video_path)

    # Create intro video matching the main video's specs
    with tempfile.NamedTemporaryFile(suffix=".mp4", delete=False) as f:
        intro_path = f.name

    try:
        print(f"Creating {args.duration}s intro...")
        create_intro_video(image_path, args.duration, video_info, audio_info, stream_order, intro_path)

        # Concatenate using stream copy (preserves original quality)
        print(f"Concatenating (stream copy)...")
        concatenate_videos(intro_path, video_path, args.output)

        print(f"Output saved to: {args.output}")
    finally:
        if os.path.exists(intro_path):
            os.unlink(intro_path)


if __name__ == "__main__":
    main()
