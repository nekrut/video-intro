#!/usr/bin/env python3
"""
video-intro: Add a title screen image to the beginning of a video.
"""

import argparse
import json
import subprocess
import sys
import tempfile
import os
from pathlib import Path


def get_video_info(video_path: str) -> dict:
    """Get video properties using ffprobe."""
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "v:0",
        "-show_entries", "stream=width,height,r_frame_rate,pix_fmt",
        "-of", "json",
        video_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    data = json.loads(result.stdout)
    stream = data["streams"][0]

    return {
        "width": int(stream["width"]),
        "height": int(stream["height"]),
        "fps_str": stream["r_frame_rate"],
        "pix_fmt": stream.get("pix_fmt", "yuv420p"),
    }


def get_audio_info(video_path: str) -> dict | None:
    """Get audio properties using ffprobe."""
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "a:0",
        "-show_entries", "stream=sample_rate,channels,channel_layout",
        "-of", "json",
        video_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    data = json.loads(result.stdout)

    if not data.get("streams"):
        return None

    stream = data["streams"][0]
    channels = int(stream.get("channels", 2))
    channel_layout = stream.get("channel_layout", "stereo" if channels >= 2 else "mono")

    return {
        "sample_rate": int(stream.get("sample_rate", 44100)),
        "channels": channels,
        "channel_layout": channel_layout,
    }


def create_video_with_intro(
    image_path: str,
    video_path: str,
    duration: float,
    output_path: str
) -> None:
    """Create output video with intro using 3-step process to preserve audio quality."""
    video_info = get_video_info(video_path)
    audio_info = get_audio_info(video_path)

    w, h = video_info["width"], video_info["height"]
    fps = video_info["fps_str"]
    pix_fmt = video_info["pix_fmt"]

    with tempfile.TemporaryDirectory() as tmpdir:
        video_only_path = os.path.join(tmpdir, "video.mp4")

        # Step 1: Create video-only with intro prepended
        video_filter = (
            f"[0:v]loop=loop=-1:size=1:start=0,"
            f"scale={w}:{h}:force_original_aspect_ratio=decrease,"
            f"pad={w}:{h}:(ow-iw)/2:(oh-ih)/2,"
            f"setsar=1,fps={fps},format={pix_fmt},"
            f"trim=duration={duration},setpts=PTS-STARTPTS[intro];"
            f"[1:v]setpts=PTS-STARTPTS[main];"
            f"[intro][main]concat=n=2:v=1:a=0[outv]"
        )

        video_args = [
            "ffmpeg", "-y",
            "-loop", "1",
            "-i", image_path,
            "-i", video_path,
            "-filter_complex", video_filter,
            "-map", "[outv]",
            "-c:v", "libx264",
            "-preset", "slow",
            "-crf", "17",
            "-an",
            video_only_path
        ]

        result = subprocess.run(video_args, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Error creating video: {result.stderr}", file=sys.stderr)
            sys.exit(1)

        if audio_info:
            # Step 2: Create audio with silent intro (preserves original audio via stream copy)
            silence_path = os.path.join(tmpdir, "silence.m4a")
            audio_combined_path = os.path.join(tmpdir, "audio.m4a")
            concat_list_path = os.path.join(tmpdir, "concat.txt")

            # Create matching silent audio
            silence_args = [
                "ffmpeg", "-y",
                "-f", "lavfi",
                "-i", f"anullsrc=channel_layout={audio_info['channel_layout']}:sample_rate={audio_info['sample_rate']}",
                "-t", str(duration),
                "-c:a", "aac",
                "-b:a", "128k",
                silence_path
            ]
            result = subprocess.run(silence_args, capture_output=True, text=True)
            if result.returncode != 0:
                print(f"Error creating silence: {result.stderr}", file=sys.stderr)
                sys.exit(1)

            # Concatenate silence + original audio (stream copy preserves quality)
            with open(concat_list_path, "w") as f:
                f.write(f"file '{silence_path}'\n")
                f.write(f"file '{video_path}'\n")

            concat_audio_args = [
                "ffmpeg", "-y",
                "-f", "concat",
                "-safe", "0",
                "-i", concat_list_path,
                "-map", "0:a",
                "-c:a", "copy",
                audio_combined_path
            ]
            result = subprocess.run(concat_audio_args, capture_output=True, text=True)
            if result.returncode != 0:
                print(f"Error concatenating audio: {result.stderr}", file=sys.stderr)
                sys.exit(1)

            # Step 3: Mux video + audio
            mux_args = [
                "ffmpeg", "-y",
                "-i", video_only_path,
                "-i", audio_combined_path,
                "-c", "copy",
                output_path
            ]
            result = subprocess.run(mux_args, capture_output=True, text=True)
            if result.returncode != 0:
                print(f"Error muxing: {result.stderr}", file=sys.stderr)
                sys.exit(1)
        else:
            # No audio - just copy video
            import shutil
            shutil.copy(video_only_path, output_path)


def main():
    parser = argparse.ArgumentParser(
        description="Add a title screen image to the beginning of a video.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  video-intro --image title.png --video screencast.mp4 --output final.mp4
  video-intro -i logo.png -v demo.mp4 -d 3 -o output.mp4
        """
    )

    parser.add_argument(
        "-i", "--image",
        required=True,
        help="Path to the title screen image (PNG, JPG, etc.)"
    )
    parser.add_argument(
        "-v", "--video",
        required=True,
        help="Path to the input video (MP4)"
    )
    parser.add_argument(
        "-d", "--duration",
        type=float,
        required=True,
        help="Duration of the title screen in seconds"
    )
    parser.add_argument(
        "-o", "--output",
        required=True,
        help="Path for the output video"
    )

    args = parser.parse_args()

    # Validate inputs
    image_path = os.path.abspath(os.path.expanduser(args.image))
    video_path = os.path.abspath(os.path.expanduser(args.video))

    if not Path(image_path).exists():
        print(f"Error: Image file not found: {image_path}", file=sys.stderr)
        sys.exit(1)

    if not Path(video_path).exists():
        print(f"Error: Video file not found: {video_path}", file=sys.stderr)
        sys.exit(1)

    if args.duration <= 0:
        print("Error: Duration must be positive", file=sys.stderr)
        sys.exit(1)

    # Check for FFmpeg
    try:
        subprocess.run(["ffmpeg", "-version"], capture_output=True, check=True)
    except FileNotFoundError:
        print("Error: FFmpeg not found. Please install FFmpeg.", file=sys.stderr)
        sys.exit(1)

    print(f"Adding {args.duration}s intro to: {video_path}")
    print("Processing...")
    create_video_with_intro(image_path, video_path, args.duration, args.output)
    print(f"Output saved to: {args.output}")


if __name__ == "__main__":
    main()
