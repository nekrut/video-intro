#!/usr/bin/env python3
"""
video-intro: Add a title screen image to the beginning of a video.
"""

import argparse
import json
import subprocess
import sys
import os
from pathlib import Path


def get_video_info(video_path: str) -> dict:
    """Get video properties using ffprobe."""
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "v:0",
        "-show_entries", "stream=width,height,r_frame_rate,pix_fmt",
        "-of", "json",
        video_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    data = json.loads(result.stdout)
    stream = data["streams"][0]

    return {
        "width": int(stream["width"]),
        "height": int(stream["height"]),
        "fps_str": stream["r_frame_rate"],
        "pix_fmt": stream.get("pix_fmt", "yuv420p"),
    }


def get_audio_info(video_path: str) -> dict | None:
    """Get audio properties using ffprobe."""
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "a:0",
        "-show_entries", "stream=codec_name,sample_rate,channels,bit_rate,channel_layout",
        "-of", "json",
        video_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    data = json.loads(result.stdout)

    if not data.get("streams"):
        return None

    stream = data["streams"][0]
    channels = int(stream.get("channels", 2))
    channel_layout = stream.get("channel_layout", "stereo" if channels >= 2 else "mono")

    bitrate = stream.get("bit_rate")
    if bitrate:
        bitrate = int(bitrate)
    else:
        bitrate = 192000  # Default to 192kbps if unknown

    return {
        "sample_rate": int(stream.get("sample_rate", 44100)),
        "channels": channels,
        "channel_layout": channel_layout,
        "bitrate": max(bitrate, 192000),  # Use at least 192kbps
    }


def create_video_with_intro(
    image_path: str,
    video_path: str,
    duration: float,
    output_path: str
) -> None:
    """Create output video with intro image prepended using filter_complex."""
    video_info = get_video_info(video_path)
    audio_info = get_audio_info(video_path)

    w, h = video_info["width"], video_info["height"]
    fps = video_info["fps_str"]
    pix_fmt = video_info["pix_fmt"]

    # Build filter_complex for video
    # [0:v] = image input (looped)
    # [1:v] = video input
    # [1:a] = audio input (if exists)
    # [2:a] = silent audio (if video has audio)

    video_filter = (
        f"[0:v]loop=loop=-1:size=1:start=0,"
        f"scale={w}:{h}:force_original_aspect_ratio=decrease,"
        f"pad={w}:{h}:(ow-iw)/2:(oh-ih)/2,"
        f"setsar=1,fps={fps},format={pix_fmt},"
        f"trim=duration={duration},setpts=PTS-STARTPTS[intro];"
        f"[1:v]setpts=PTS-STARTPTS[main];"
        f"[intro][main]concat=n=2:v=1:a=0[outv]"
    )

    if audio_info:
        audio_filter = (
            f";[2:a]atrim=duration={duration},asetpts=PTS-STARTPTS[introa];"
            f"[1:a]asetpts=PTS-STARTPTS[maina];"
            f"[introa][maina]concat=n=2:v=0:a=1[outa]"
        )
        filter_complex = video_filter + audio_filter
        maps = ["-map", "[outv]", "-map", "[outa]"]
    else:
        filter_complex = video_filter
        maps = ["-map", "[outv]"]

    args = [
        "ffmpeg", "-y",
        "-loop", "1",
        "-i", image_path,
        "-i", video_path,
    ]

    if audio_info:
        args.extend([
            "-f", "lavfi",
            "-i", f"anullsrc=channel_layout={audio_info['channel_layout']}:sample_rate={audio_info['sample_rate']}"
        ])

    args.extend([
        "-filter_complex", filter_complex,
        *maps,
        "-c:v", "libx264",
        "-preset", "slow",
        "-crf", "17",
        "-pix_fmt", pix_fmt,
    ])

    if audio_info:
        # Use high quality audio settings
        args.extend([
            "-c:a", "aac",
            "-b:a", f"{audio_info['bitrate']}",
            "-ar", str(audio_info['sample_rate']),
        ])

    args.append(output_path)

    result = subprocess.run(args, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Error: {result.stderr}", file=sys.stderr)
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Add a title screen image to the beginning of a video.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  video-intro --image title.png --video screencast.mp4 --output final.mp4
  video-intro -i logo.png -v demo.mp4 -d 3 -o output.mp4
        """
    )

    parser.add_argument(
        "-i", "--image",
        required=True,
        help="Path to the title screen image (PNG, JPG, etc.)"
    )
    parser.add_argument(
        "-v", "--video",
        required=True,
        help="Path to the input video (MP4)"
    )
    parser.add_argument(
        "-d", "--duration",
        type=float,
        required=True,
        help="Duration of the title screen in seconds"
    )
    parser.add_argument(
        "-o", "--output",
        required=True,
        help="Path for the output video"
    )

    args = parser.parse_args()

    # Validate inputs
    image_path = os.path.abspath(os.path.expanduser(args.image))
    video_path = os.path.abspath(os.path.expanduser(args.video))

    if not Path(image_path).exists():
        print(f"Error: Image file not found: {image_path}", file=sys.stderr)
        sys.exit(1)

    if not Path(video_path).exists():
        print(f"Error: Video file not found: {video_path}", file=sys.stderr)
        sys.exit(1)

    if args.duration <= 0:
        print("Error: Duration must be positive", file=sys.stderr)
        sys.exit(1)

    # Check for FFmpeg
    try:
        subprocess.run(["ffmpeg", "-version"], capture_output=True, check=True)
    except FileNotFoundError:
        print("Error: FFmpeg not found. Please install FFmpeg.", file=sys.stderr)
        sys.exit(1)

    print(f"Adding {args.duration}s intro to: {video_path}")
    print("Encoding (this may take a moment)...")
    create_video_with_intro(image_path, video_path, args.duration, args.output)
    print(f"Output saved to: {args.output}")


if __name__ == "__main__":
    main()
